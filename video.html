<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Wireframe Letters + Local GLB Model RGB</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #111;
      font-family: sans-serif;
    }
    canvas {
      display: block;
    }
    button {
      position: absolute;
      left: 10px;
      z-index: 10;
      padding: 8px 12px;
      font-size: 14px;
      font-weight: bold;
      background: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    #startBtn { top: 10px; }
    #stopBtn { top: 50px; }
  </style>
</head>
<body>

  <button id="startBtn" onclick="startRecording()">Start Recording</button>
  <button id="stopBtn" onclick="stopRecording()">Stop Recording</button>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

  <script>
    let scene, camera, renderer;
    let letters = [];
    let flying = false;
    let glbModel = null;
    let glbMaterials = [];

    const text = "Fuck-you";

    let recorder;
    let recordedChunks = [];

    init();

    function init() {
      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(
        50,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.z = 20;

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const loader = new THREE.FontLoader();
      loader.load(
        "https://threejs.org/examples/fonts/helvetiker_regular.typeface.json",
        function (font) {
          createLetters(font);
          loadGLBModel();
          animate();
        }
      );

      window.addEventListener("click", () => {
        if (!flying) {
          flying = true;
          const now = Date.now();
          letters.forEach((letter, i) => {
            letter.state = "flying";
            letter.startTime = now + i * 200;
            letter.position.copy(letter.initialPosition);
            letter.rotation.set(0, 0, 0);
            letter.rotationSpeed = { x: 0.1, y: 0.1 };
          });
        }
      });

      window.addEventListener("resize", onWindowResize);

      // Hotkeys: R = start recording, S = stop recording
      window.addEventListener("keydown", (e) => {
        if (e.key.toLowerCase() === 'r') startRecording();
        if (e.key.toLowerCase() === 's') stopRecording();
      });
    }

    function createLetters(font) {
      letters = [];
      let xOffset = 0;

      for (let i = 0; i < text.length; i++) {
        const char = text[i];
        const geometry = new THREE.TextGeometry(char, {
          font: font,
          size: 4,
          height: 0.5,
          curveSegments: 12,
          bevelEnabled: false,
        });

        geometry.computeBoundingBox();
        const width = geometry.boundingBox.max.x - geometry.boundingBox.min.x;
        const height = geometry.boundingBox.max.y - geometry.boundingBox.min.y;
        geometry.translate(-width / 2, -height / 2, 0);

        const material = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          wireframe: true,
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.x = xOffset + width / 2;
        mesh.position.y = -5;
        mesh.index = i;
        mesh.initialPosition = mesh.position.clone();
        mesh.state = "idle";
        mesh.startTime = 0;
        mesh.rotationSpeed = { x: 0, y: 0 };

        scene.add(mesh);
        letters.push(mesh);

        xOffset += width + 0.5;
      }

      const totalWidth = xOffset - 0.5;
      letters.forEach((letter) => {
        letter.position.x -= totalWidth / 2;
        letter.initialPosition = letter.position.clone();
      });
    }

    function loadGLBModel() {
      const gltfLoader = new THREE.GLTFLoader();
      gltfLoader.load(
        "./72ff033c69c7ac43d6252b8bb14e8d5e.glb",
        (gltf) => {
          glbModel = gltf.scene;
          glbModel.scale.set(2, 2, 2);
          glbModel.position.set(7, 5, 0);

          glbModel.traverse((child) => {
            if (child.isMesh) {
              const wireMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                wireframe: true,
              });
              child.material = wireMat;
              glbMaterials.push(wireMat);
            }
          });

          scene.add(glbModel);
        },
        undefined,
        (error) => {
          console.error("Error loading GLB model:", error);
        }
      );
    }

    function animate() {
      requestAnimationFrame(animate);

      const now = Date.now();

      letters.forEach((letter) => {
        const time = ((now * 0.001) * 0.2 + letter.index * 0.2) % 1;
        const rgb = hslToRgb(time, 1, 0.5);
        letter.material.color.setRGB(rgb[0], rgb[1], rgb[2]);

        if (letter.state === "flying") {
          const elapsed = (now - letter.startTime) / 1000;
          if (elapsed >= 0) {
            const flightDuration = 3;
            const progress = Math.min(elapsed / flightDuration, 1);
            const easedProgress = 1 - Math.pow(1 - progress, 3);

            letter.position.y = letter.initialPosition.y + 6 * easedProgress;
            letter.rotation.x += letter.rotationSpeed.x;
            letter.rotation.y += letter.rotationSpeed.y;

            if (progress >= 1) {
              letter.state = "stopping";
            }
          }
        } else if (letter.state === "stopping") {
          const deceleration = 0.02;
          letter.rotationSpeed.x = Math.max(letter.rotationSpeed.x - deceleration, 0);
          letter.rotationSpeed.y = Math.max(letter.rotationSpeed.y - deceleration, 0);

          letter.rotation.x += letter.rotationSpeed.x;
          letter.rotation.y += letter.rotationSpeed.y;

          if (letter.rotationSpeed.x <= 0 && letter.rotationSpeed.y <= 0) {
            letter.rotation.set(0, 0, 0);
            letter.state = "done";
            letter.position.y = letter.initialPosition.y + 6;
          }
        }
      });

      if (glbMaterials.length > 0) {
        const modelTime = (now * 0.001) * 0.2 % 1;
        const rgbModel = hslToRgb(modelTime, 1, 0.5);
        glbMaterials.forEach((mat) => {
          mat.color.setRGB(rgbModel[0], rgbModel[1], rgbModel[2]);
        });
      }

      renderer.render(scene, camera);
    }

    function hslToRgb(h, s, l) {
      let r, g, b;
      if (s === 0) {
        r = g = b = l;
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1 / 6) return p + (q - p) * 6 * t;
          if (t < 1 / 2) return q;
          if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
          return p;
        };
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
      }
      return [r, g, b];
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function startRecording() {
      const canvasStream = renderer.domElement.captureStream(60);
      recorder = new MediaRecorder(canvasStream, { mimeType: 'video/webm' });

      recorder.ondataavailable = (event) => {
        if (event.data.size > 0) recordedChunks.push(event.data);
      };

      recorder.onstop = () => {
        const blob = new Blob(recordedChunks, { type: 'video/webm' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'animation.webm';
        a.click();
        recordedChunks = [];
      };

      recorder.start();
      console.log("Recording started...");
    }

    function stopRecording() {
      if (recorder && recorder.state === "recording") {
        recorder.stop();
        console.log("Recording stopped.");
      }
    }
  </script>
</body>
</html>
